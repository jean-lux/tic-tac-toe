const WebSocket = require('ws');

/**
 * TicTacToe Websocket server class
 * @example
 * To run the server, install nodejs and run the following command
 * node server.js
 * Optionally, to run in debug mode use the following command:
 * node server.js -debug
 * To play the game using the browser run browser-client.html
 */

class Server {
    /**
     *  Server class constructor
     *  @constructor
     *  @param {string} address server ip or url, if null the default value is 127.0.0.1
     *  @param {string} port port number to establish a connection on. If null the default port is set to 1337..
     *  @returns {Object} server object and methods.
     */
    constructor(address, port){
        this.setDebugMode()
        this.address = address || "127.0.0.1"
        this.port = port || 1337
        this.server = new WebSocket.Server({
            port: this.port
        });
        this.server.on("connection", this.addSession.bind(this))
        // SESSION
        this.sessions = new Object()
        //INIT
        console.log(`Tictac server init @${this.address}:${this.port}`)
    }
    error(err) {
        this.exit(id)
    }
    /**
     *  Generates a session id
     *  @returns {string} A short session id
     */
    sessionID() {
        let fp = (Math.random() * 46656) | 0;
        let sp = (Math.random() * 46656) | 0;
        fp = ("000" + fp.toString(36)).slice(-3);
        sp = ("000" + sp.toString(36)).slice(-3);
        return fp + sp;
    }
    /**
     *  Drops/remove the session
     *  @param {string} id the session id to remove
     */
    dropSession(id) {
        if (this._debug) {
            console.log("droping session: ", id)
        }
        this.sessions[id] = null
    }
    /**
     *  add a new session
     *  @param {class} socket a referance to the websocket object
     */
    addSession(socket) {
        let id = this.sessionID()
        let session = new Session(id, this, socket)
        this.sessions[id] = session
    }
    /**
    * runs the server in debug mode
     */
    setDebugMode(debug){
       process.argv.forEach((val, index, array) => {
         if(val == "-debug" || val == "-D"){
             this._debug = true
         }
       })
    }
}

/**
 * Server session class
 */
class Session {
    /**
     *  Session class constructor
     *  @constructor
     *  @param {string} id required session id generated by the server class.
     *  @param {class} server required Server object.
     *  @param {class} socket required Websocket object.
     *  @returns {Object} A client session.
     */
    constructor(id, server, socket){
        this.id = id
        this._debug = server._debug
        if (this._debug) console.log("adding session ", id)
        socket.on("message", this.read.bind(this))
        socket.on("pong", this.pong.bind(this))
        this._socket = socket
        this._server = server
        this._interval = setInterval(this.ping.bind(this), this._pingInterval || 5000);
        this.init()
    }
    /**
     *  Initialises a new game and board
     */
    init(ctx) {
        this._initialised = true
        this.board = new Board("X", "O")
        this.write({
            prompt: {
                key: "name",
                question: "What your name?",
            }
        })
    }
    /**
     *  Called whenever a new message is sent from the client
     *  @param {string} data data in json format sent from the client
     */
    read(data) {
        if (!this._initialised) return this.init()
        let ctx = JSON.parse(data)
        if (ctx.exit) {
            return this.exit()
        } else if (ctx.prompt) {
            return this.prompt(ctx.prompt)
        } else if (ctx.playEvent) {
            this.playEvent(ctx.playEvent)
        }
    }
    /**
     *  Encodes and emits data to the client
     *  @param {Object} data A valid object to stringify and emit to client
     */
    write(data) {
        let ctx = JSON.stringify(data)
        // if(this._debug) console.log("writing data to client: ", ctx)
        this._socket.send(ctx)
    }
    /**
     *  Called whenever a player makes a move
     *  evaluates the next move and respondes accordingly
     *  @param {Object} ctx A valid object sent from client
     */
    playEvent(ctx) {
        if (!this.board.validMove(ctx.key)) {
            ctx.exception = "invalid move"
            return this.write(ctx)
        }
        let reset = false
        this.board.setState(ctx.key, ctx.symbol)
        let move = this.board.getMove(this.board.state, this.board.opponent)
        if (move.index || move.index == 0) {
            this.board.setState(move.index, this.board.opponent)
        }
        if (this.board.checkWinner(this.board.state, this.board.opponent)) {
            ctx.prompt = this.board.setWinner(this.board.opponent)
            reset = true
        }
        if (this.board.moves >= 9) {
            ctx.prompt = this.board.tie()
            reset = true
        }
        ctx.state = this.board.state
        if (reset) this.board.reset()
        this.write(ctx)
    }
    /**
     *  Called whenever a prompt response from the client is made.
     *  @param {Object} ctx A valid prompt object from the client
     */
    prompt(ctx) {
        if (ctx.key) {
            if (ctx.key == "name") {
                this.board.setPlayer(ctx.response)
            } else if (ctx.key == "help") {
                this.board._help = true
            } else if (ctx.key == "start") {
                this.board._stated = true
            }

        }
        if (!this.board._help) {
            return this.write({
                prompt: {
                    key: "help",
                    question: `Hi ${this.board.getPlayer()}, use these keys on your keyboard to play. hit enter to continue.`,
                }
            })

        } else if (!this.board._started) {
            return this.write({
                prompt: {
                    key: "start",
                }
            })
        }
    }
    /**
     *  Terminates the session, clears the interval on broken connections
     */
    exit() {
        clearInterval(this._interval);
        this._socket.terminate();
        this._server.dropSession(this.id)
    }
    /**
     *  ping the client to check if its still available
     */
    ping() {
        if (this._isAlive === false) return this.exit()
        this._isAlive = false;
        this._socket.ping(function() {});
    }
    /**
     *  called whenever a new pong is received from the client
     */
    pong() {
        this._isAlive = true
    }
}

/**
 * TicTacToe Board class
 */
class Board {
    /**
     *  Board class attached to each game session
     *  @constructor
     *  @param {string} player player symbol the defualt is "X".
     *  @param {Class} opponent opponent symbol the default is "O"
     *  @returns {Object} A new game/board used with the Session Class.
     */
     constructor(player, opponent){
         this.player = player || "X"
         this.opponent = opponent || "O"
         this.emptyState()
     }
     /**
      *  Evaluates the next move based on the minimax algorithm
      *  @param {Array} state The current game state
      *  @param {string} player the players symbol "X" or "O"
      */
      getMove(state, player) {
          //available slots
          var slots = this.getSlots(state)
          if (this.checkWinner(state, this.player)) {
              return {
                  score: -10
              };
          } else if (this.checkWinner(state, this.opponent)) {
              return {
                  score: 10
              };
          } else if (slots.length === 0) {
              return {
                  score: 0,
                  tie: true
              };
          }

          // an array to collect all the objects
          var moves = [];

          // loop through available spots
          for (var i = 0; i < slots.length; i++) {
              //create an object for each and store the index of that spot that was stored as a number in the object's index key
              var move = {};
              move.index = state[slots[i]];

              // set the empty spot to the current player
              state[slots[i]] = player;

              //if collect the score resulted from calling getMove on the opponent of the current player
              if (player == this.opponent) {
                  var result = this.getMove(state, this.player);
                  move.score = result.score;
              } else {
                  var result = this.getMove(state, this.opponent);
                  move.score = result.score;
              }

              //reset the spot to empty
              state[slots[i]] = move.index;

              // push the object to the array
              moves.push(move);
          }

          // if it is the computer's turn loop over the moves and choose the move with the highest score
          var bestMove;
          if (player === this.opponent) {
              var bestScore = -10000;
              for (var i = 0; i < moves.length; i++) {
                  if (moves[i].score > bestScore) {
                      bestScore = moves[i].score;
                      bestMove = i;
                  }
              }
          } else {

              // else loop over the moves and choose the move with the lowest score
              var bestScore = 10000;
              for (var i = 0; i < moves.length; i++) {
                  if (moves[i].score < bestScore) {
                      bestScore = moves[i].score;
                      bestMove = i;
                  }
              }
          }

          // return the chosen move (object) from the array to the higher depth
          return moves[bestMove];
      }
     /**
      *  Return available/left slot to play
      *  @param {Array} State The current game state
      */
     getSlots(state) {
         return state.filter(s => s != "O" && s != "X");
     }
     /**
      *  Check the winner and return the results
      *  @param {Array} State The current game state
      *  @param {string} player the players symbol "X" or "O"
      */
     checkWinner(state, player) {
         if (
             (state[0] == player && state[1] == player && state[2] == player) ||
             (state[3] == player && state[4] == player && state[5] == player) ||
             (state[6] == player && state[7] == player && state[8] == player) ||
             (state[0] == player && state[3] == player && state[6] == player) ||
             (state[1] == player && state[4] == player && state[7] == player) ||
             (state[2] == player && state[5] == player && state[8] == player) ||
             (state[0] == player && state[4] == player && state[8] == player) ||
             (state[2] == player && state[4] == player && state[6] == player)
         ) {
             return true;
         } else {
             return false;
         }
     }
     /**
      *  Register and Set the players name
      *  @param {string} name The players name, if name is not set the default in anonymous.
      */
     setPlayer(name) {
         if (name == true) {
             name = "anonymous"
         }
         this.name = name
     }
     /**
      *  Return the players abne
      */
     getPlayer() {
         return this.name
     }
     /**
      *  Return a message to emit to client whenever there is winner
      *  @param {string} player The players symbol "X" or "O"
      */
     setWinner(player) {
         return {
             over: true,
             key: "win",
             winner: player,
             question: "To start a new game hit enter",
         }
     }
     /**
      *  Updates and set the state in sync with the client
      *  @param {number} key A number from 1 - 9
      *  @param {string} player The players symbol "X" or "O"
      */
     setState(key, player) {
         this.state[key] = player
         this.moves++
     }
     /**
      *  Validates a move on the board
      *  Evaluates whenever a player make a move
      *  @param {number} key a number from 1 - 9
      */
     validMove(key) {
         if (typeof this.state[key] === "number") return true
         return false
     }
     /**
      *  Return the correct message to emit to client whenever there is a tie.
      */
     tie() {
         return {
             key: "tie",
             question: "Its a draw hit enter to play again",
         }
     }
     /**
      *  Return an empty message to emit to client
      */
     reset() {
         this.emptyState()
         return {
             key: "start",
         }
     }
     /**
      *  Sets an empty state and resets moves.
      */
     emptyState() {
         this.moves = 0
         this.state = [0, 1, 2, 3, 4, 5, 6, 7, 8]
     }
}

// RUN
var server = new Server()
